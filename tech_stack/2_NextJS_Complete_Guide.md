# Next.js Complete Guide - Theoretical Foundation

## Table of Contents
1. [Introduction](#introduction)
2. [Core Concepts](#core-concepts)
3. [App Router](#app-router)
4. [Pages Router](#pages-router)
5. [Rendering Strategies](#rendering-strategies)
6. [Data Fetching](#data-fetching)
7. [API Routes](#api-routes)
8. [Middleware](#middleware)
9. [Authentication](#authentication)
10. [Performance Optimization](#performance-optimization)
11. [Deployment](#deployment)
12. [Best Practices](#best-practices)

---

## Introduction

### What is Next.js?
Next.js is a React framework that enables you to build full-stack web applications with features like:
- Server-side rendering (SSR)
- Static generation (SSG)
- Incremental Static Regeneration (ISR)
- API routes for backend functionality
- Automatic code splitting and optimization

### Why Use Next.js?

**Advantages:**
- Built-in optimization (images, fonts, scripts)
- Multiple rendering strategies
- File-based routing
- API routes without separate backend
- Excellent developer experience
- Great for SEO with SSR/SSG
- Automatic code splitting
- TypeScript support
- Environment variables management

**Comparison with React:**
```
React                          | Next.js
---                            | ---
Client-side rendering only     | SSR, SSG, CSR, ISR
Manual routing (React Router)  | File-based routing
No backend out of the box      | Built-in API routes
Manual optimization            | Automatic optimization
```

### Next.js Versions

**App Router (New - Recommended)**
- Introduced in Next.js 13+
- Directory-based routing in `app/` folder
- Server Components by default
- Better organization and performance

**Pages Router (Legacy)**
- Traditional file-based routing
- Still supported and widely used
- Directory-based routing in `pages/` folder

---

## Core Concepts

### Project Structure (App Router)
```
my-app/
├── app/
│   ├── layout.js          # Root layout
│   ├── page.js            # Home page (/)
│   ├── about/
│   │   └── page.js        # /about
│   ├── blog/
│   │   ├── page.js        # /blog
│   │   ├── [slug]/
│   │   │   └── page.js    # /blog/[slug]
│   │   └── layout.js      # Blog layout
│   └── api/
│       └── users/
│           └── route.js   # API endpoint
├── public/                # Static files
├── lib/                   # Utilities
├── components/            # React components
├── styles/                # Global styles
├── next.config.js         # Next.js configuration
├── package.json
└── .env.local             # Environment variables
```

### Routing Fundamentals

**Automatic Route Creation**
Routes are automatically created based on file structure:

| File Location | Route |
|---|---|
| `app/page.js` | `/` |
| `app/about/page.js` | `/about` |
| `app/blog/[id]/page.js` | `/blog/123` |
| `app/blog/[...slug]/page.js` | `/blog/a/b/c` |

**Dynamic Routes**
```
[id] - Single dynamic segment
[...slug] - Catch-all route
[[...slug]] - Optional catch-all
```

**Route Groups**
Group routes without affecting URL structure:
```
app/
├── (marketing)/
│   ├── about/
│   │   └── page.js    # /about
│   └── contact/
│       └── page.js    # /contact
└── (dashboard)/
    ├── profile/
    │   └── page.js    # /profile
    └── settings/
        └── page.js    # /settings
```

### File Conventions

**Special Files in App Router:**

| File | Purpose |
|---|---|
| `layout.js` | Shared layout for route segment and children |
| `page.js` | Unique content of a route |
| `route.js` | API endpoint |
| `loading.js` | Loading state |
| `error.js` | Error boundary |
| `not-found.js` | Not found fallback |
| `template.js` | Re-rendered layout (vs layout persists) |

### Layouts

**Root Layout**
```javascript
// app/layout.js
export const metadata = {
  title: 'My App',
  description: 'Generated by create next app',
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

**Nested Layouts**
```javascript
// app/dashboard/layout.js
export default function DashboardLayout({ children }) {
  return (
    <div>
      <nav>Sidebar Navigation</nav>
      <main>{children}</main>
    </div>
  );
}
```

### Pages

```javascript
// app/page.js
export default function Home() {
  return <h1>Welcome to Next.js</h1>;
}

// app/about/page.js
export default function About() {
  return <h1>About Page</h1>;
}

// Dynamic route: app/blog/[id]/page.js
export default function BlogPost({ params }) {
  return <h1>Blog Post: {params.id}</h1>;
}
```

### Server Components

By default, components in the App Router are Server Components.

**Characteristics:**
- Run only on the server
- Can access databases and files directly
- Keep secrets on the server
- Reduce JavaScript sent to client
- Support async/await

```javascript
// app/page.js - Server Component by default
async function getData() {
  const res = await fetch('https://api.example.com/data');
  return res.json();
}

export default async function Home() {
  const data = await getData();
  return <div>{data}</div>;
}
```

### Client Components

Components that run in the browser and use interactive features.

```javascript
// app/components/Counter.js
'use client'; // Marks this as a Client Component

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

**When to Use Client Components:**
- Interactive features (useState, useEffect)
- Event listeners (onClick, onChange)
- Browser APIs (localStorage, window)
- Custom hooks

### Server vs Client Components Comparison

| Feature | Server | Client |
|---|---|---|
| Fetch data | ✅ | ❌ (use API routes) |
| Database access | ✅ | ❌ |
| Keep secrets | ✅ | ❌ |
| Large dependencies | ✅ | ❌ |
| Use hooks | ❌ | ✅ |
| Use context | ❌ | ✅ |
| Use browser APIs | ❌ | ✅ |

---

## App Router (New Routing System)

### Dynamic Routes

**Single Dynamic Segment**
```javascript
// app/blog/[id]/page.js
export default function BlogPost({ params }) {
  return <h1>Post ID: {params.id}</h1>;
}

// URL: /blog/123 → params = { id: '123' }
```

**Multiple Dynamic Segments**
```javascript
// app/blog/[year]/[month]/page.js
export default function BlogArchive({ params }) {
  return <h1>{params.year}/{params.month}</h1>;
}

// URL: /blog/2024/01 → params = { year: '2024', month: '01' }
```

**Catch-all Routes**
```javascript
// app/docs/[...slug]/page.js
export default function Docs({ params }) {
  return <div>Docs: {params.slug.join('/')}</div>;
}

// URL: /docs/a/b/c → params = { slug: ['a', 'b', 'c'] }
```

**Optional Catch-all Routes**
```javascript
// app/blog/[[...slug]]/page.js
export default function Blog({ params }) {
  if (!params.slug) return <h1>Blog Home</h1>;
  return <h1>Post: {params.slug.join('/')}</h1>;
}

// URL: /blog → shows home
// URL: /blog/2024/01 → shows post
```

### Dynamic Route Generation

**generateStaticParams** - Pre-generate routes at build time
```javascript
// app/blog/[id]/page.js
export async function generateStaticParams() {
  const posts = await fetch('https://api.example.com/posts').then(res => res.json());

  return posts.map((post) => ({
    id: post.id.toString(),
  }));
}

export default function BlogPost({ params }) {
  return <h1>Post: {params.id}</h1>;
}
```

### Linking and Navigation

**Link Component**
```javascript
import Link from 'next/link';

export default function Navigation() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
      <Link href={`/blog/${postId}`}>Blog Post</Link>
    </nav>
  );
}
```

**useRouter Hook**
```javascript
'use client';

import { useRouter } from 'next/navigation'; // Note: app router import

export default function GoBack() {
  const router = useRouter();

  return (
    <button onClick={() => router.push('/blog')}>
      Go to Blog
    </button>
  );
}
```

**URL Patterns**
```javascript
// Dynamic route
router.push(`/blog/${id}`);

// With query params
router.push(`/search?q=nextjs`);

// Replace history
router.replace('/dashboard');

// Programmatic navigation
router.back();
router.forward();
router.refresh(); // Refresh data from server
```

---

## Pages Router (Legacy but Important)

### File-Based Routing

```
pages/
├── index.js           # /
├── about.js           # /about
├── blog/
│   ├── index.js       # /blog
│   └── [id].js        # /blog/[id]
└── api/
    └── hello.js       # API route
```

### Dynamic Routes with Pages Router

```javascript
// pages/blog/[id].js
import { useRouter } from 'next/router'; // pages router import

export default function BlogPost() {
  const router = useRouter();
  const { id } = router.query;

  if (router.isFallback) {
    return <div>Loading...</div>;
  }

  return <h1>Post: {id}</h1>;
}

export async function getStaticPaths() {
  return {
    paths: [
      { params: { id: '1' } },
      { params: { id: '2' } },
    ],
    fallback: 'blocking', // 'blocking' | false | true
  };
}

export async function getStaticProps({ params }) {
  const data = await fetch(`/api/posts/${params.id}`);
  return {
    props: { post: data },
    revalidate: 3600, // ISR
  };
}
```

---

## Rendering Strategies

### Rendering Strategy Comparison

| Strategy | Rendering | When | Use Case |
|---|---|---|---|
| **SSR** | Server | Request time | Dynamic content, user-specific data |
| **SSG** | Build time | Static content | Blogs, marketing sites |
| **ISR** | Build + On-demand | Semi-static content | Frequently updated data |
| **CSR** | Browser | Interactive | User interactions |

### Static Site Generation (SSG)

Pre-render pages at build time.

**Characteristics:**
- Generated at build time
- Cached on CDN
- Ultra-fast page loads
- Great for SEO

```javascript
// app/blog/[slug]/page.js
export async function generateStaticParams() {
  const posts = await getPosts();
  return posts.map((post) => ({
    slug: post.slug,
  }));
}

export default function BlogPost({ params }) {
  const post = getPost(params.slug);
  return <article>{post.content}</article>;
}
```

### Server-Side Rendering (SSR)

Render on each request.

**App Router:**
```javascript
// app/dashboard/page.js
async function getData() {
  const res = await fetch('https://api.example.com/data', {
    cache: 'no-store', // SSR behavior
  });
  return res.json();
}

export default async function Dashboard() {
  const data = await getData();
  return <div>{data}</div>;
}
```

**Pages Router:**
```javascript
// pages/dashboard.js
export async function getServerSideProps(context) {
  const data = await fetch('https://api.example.com/data');
  return {
    props: { data },
  };
}

export default function Dashboard({ data }) {
  return <div>{data}</div>;
}
```

### Client-Side Rendering (CSR)

Render in the browser.

```javascript
'use client';

import { useEffect, useState } from 'react';

export default function Dashboard() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(data => {
        setData(data);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;
  return <div>{data}</div>;
}
```

### Incremental Static Regeneration (ISR)

Combine benefits of SSG and SSR.

```javascript
// app/blog/[slug]/page.js
export async function generateStaticParams() {
  return [{ slug: 'popular-post' }];
}

async function getPost(slug) {
  return fetch(`https://api.example.com/posts/${slug}`, {
    next: { revalidate: 60 }, // ISR: revalidate every 60 seconds
  }).then(res => res.json());
}

export default async function Post({ params }) {
  const post = await getPost(params.slug);
  return <article>{post.content}</article>;
}
```

### Cache Strategies

**Caching Hierarchy in App Router:**

```javascript
// Full caching (default for GET requests)
const data = await fetch('https://api.example.com/data');

// Revalidate every hour
const data = await fetch('https://api.example.com/data', {
  next: { revalidate: 3600 }
});

// No cache (SSR)
const data = await fetch('https://api.example.com/data', {
  cache: 'no-store'
});

// Revalidate on-demand
const data = await fetch('https://api.example.com/data', {
  next: { tags: ['posts'] }
});
```

**On-Demand Revalidation:**
```javascript
// app/api/revalidate/route.js
import { revalidateTag } from 'next/cache';

export async function POST(request) {
  revalidateTag('posts');
  return Response.json({ revalidated: true });
}
```

---

## Data Fetching

### Fetching Patterns

**In Server Components:**
```javascript
// app/page.js
async function getPosts() {
  const res = await fetch('https://api.example.com/posts', {
    next: { revalidate: 3600 }
  });
  return res.json();
}

export default async function Home() {
  const posts = await getPosts();
  return (
    <div>
      {posts.map(post => (
        <h2 key={post.id}>{post.title}</h2>
      ))}
    </div>
  );
}
```

**Using Third-Party Libraries:**
```javascript
// Using ORM like Prisma
import { prisma } from '@/lib/prisma';

async function getPosts() {
  return prisma.post.findMany({
    orderBy: { createdAt: 'desc' }
  });
}

export default async function Home() {
  const posts = await getPosts();
  return <div>{/* render posts */}</div>;
}
```

### Request Memoization

Next.js automatically deduplicates fetch requests with the same URL in a single render pass.

```javascript
// Both calls are memoized - only 1 request sent
async function getUser() {
  const user = await fetch('https://api.example.com/user');
  return user.json();
}

export default async function Home() {
  const user1 = await getUser();
  const user2 = await getUser(); // Memoized, same result
  return <div>{user1.name}</div>;
}
```

### Error Handling

**Try-Catch in Server Components:**
```javascript
async function getPost(id) {
  try {
    const res = await fetch(`/api/posts/${id}`, {
      cache: 'no-store'
    });
    if (!res.ok) throw new Error('Failed to fetch');
    return res.json();
  } catch (error) {
    console.error('Error fetching post:', error);
    return null;
  }
}

export default async function Post({ params }) {
  const post = await getPost(params.id);
  if (!post) return <div>Post not found</div>;
  return <article>{post.content}</article>;
}
```

---

## API Routes

### Creating API Endpoints

```javascript
// app/api/hello/route.js
export async function GET(request) {
  return Response.json({ message: 'Hello' });
}

export async function POST(request) {
  const data = await request.json();
  return Response.json({ data }, { status: 201 });
}

export async function PUT(request) {
  const data = await request.json();
  return Response.json({ updated: data });
}

export async function DELETE(request) {
  return Response.json({ deleted: true });
}
```

### Route Handlers

```javascript
// app/api/users/[id]/route.js
export async function GET(request, { params }) {
  const userId = params.id;
  const user = await fetchUser(userId);
  return Response.json(user);
}

export async function PUT(request, { params }) {
  const data = await request.json();
  const user = await updateUser(params.id, data);
  return Response.json(user);
}
```

### Request Methods

```javascript
// app/api/upload/route.js
export async function POST(request) {
  // Get request body
  const data = await request.json();

  // Get headers
  const token = request.headers.get('authorization');

  // Get query parameters
  const { searchParams } = new URL(request.url);
  const page = searchParams.get('page');

  // Get form data
  const formData = await request.formData();

  return Response.json({ success: true });
}
```

### Error Handling in API Routes

```javascript
// app/api/posts/[id]/route.js
export async function GET(request, { params }) {
  try {
    const post = await getPost(params.id);
    if (!post) {
      return Response.json(
        { error: 'Post not found' },
        { status: 404 }
      );
    }
    return Response.json(post);
  } catch (error) {
    return Response.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

---

## Middleware

### Introduction to Middleware

Functions that run before a request is processed.

```javascript
// middleware.js (root of project)
import { NextResponse } from 'next/server';

export function middleware(request) {
  // Modify request headers
  const requestHeaders = new Headers(request.headers);
  requestHeaders.set('x-pathname', request.nextUrl.pathname);

  return NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  });
}

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/api/:path*',
  ],
};
```

### Authentication Middleware

```javascript
// middleware.js
import { NextResponse } from 'next/server';

export function middleware(request) {
  const token = request.cookies.get('authToken')?.value;

  // Check if user is authenticated
  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/dashboard/:path*'],
};
```

### Conditional Routing

```javascript
// middleware.js
import { NextResponse } from 'next/server';

export function middleware(request) {
  const { pathname } = request.nextUrl;

  // Redirect old URLs
  if (pathname === '/old-page') {
    return NextResponse.redirect(new URL('/new-page', request.url));
  }

  // Add security headers
  const response = NextResponse.next();
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('X-Frame-Options', 'DENY');

  return response;
}
```

---

## Authentication

### Authentication Flow

```
User Login → Generate JWT → Store Token (Cookie/LocalStorage)
→ Include Token in Requests → Verify Token on Server
```

### JWT-Based Authentication

**Backend Setup:**
```javascript
// app/api/login/route.js
import jwt from 'jsonwebtoken';

export async function POST(request) {
  const { email, password } = await request.json();

  // Verify credentials
  const user = await verifyUser(email, password);
  if (!user) {
    return Response.json({ error: 'Invalid credentials' }, { status: 401 });
  }

  // Create JWT
  const token = jwt.sign(
    { userId: user.id, email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );

  // Set secure cookie
  const response = Response.json({ success: true });
  response.cookies.set('authToken', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 7 * 24 * 60 * 60,
  });

  return response;
}
```

**Middleware Authentication:**
```javascript
// middleware.js
import { jwtVerify } from 'jose';

const secret = new TextEncoder().encode(process.env.JWT_SECRET);

export async function middleware(request) {
  const token = request.cookies.get('authToken')?.value;

  if (!token) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  try {
    await jwtVerify(token, secret);
    return NextResponse.next();
  } catch (error) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
}

export const config = {
  matcher: ['/dashboard/:path*'],
};
```

**Client-Side Authentication:**
```javascript
// app/components/LoginForm.js
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

export default function LoginForm() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  async function handleLogin(e) {
    e.preventDefault();
    setLoading(true);

    const response = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: e.target.email.value,
        password: e.target.password.value,
      }),
    });

    if (response.ok) {
      router.push('/dashboard');
    }

    setLoading(false);
  }

  return (
    <form onSubmit={handleLogin}>
      <input type="email" name="email" required />
      <input type="password" name="password" required />
      <button disabled={loading}>{loading ? 'Logging in...' : 'Login'}</button>
    </form>
  );
}
```

### Session Management

**Using NextAuth.js:**
```javascript
// app/api/auth/[...nextauth]/route.js
import NextAuth from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';

export const authOptions = {
  providers: [
    CredentialsProvider({
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        const user = await verifyUser(credentials.email, credentials.password);
        if (user) {
          return user;
        }
        return null;
      },
    }),
  ],
  pages: {
    signIn: '/login',
  },
};

export const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
```

---

## Performance Optimization

### Image Optimization

**Next.js Image Component:**
```javascript
import Image from 'next/image';

// Optimized with automatic responsive images
<Image
  src="/hero.png"
  alt="Hero"
  width={1200}
  height={600}
  priority // Load above the fold
/>

// Responsive with fill property
<Image
  src="/hero.png"
  alt="Hero"
  fill
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
  priority
/>
```

### Font Optimization

```javascript
// app/layout.js
import { Inter } from 'next/font/google';

const inter = Inter({ subsets: ['latin'] });

export default function RootLayout({ children }) {
  return (
    <html lang="en" className={inter.className}>
      <body>{children}</body>
    </html>
  );
}
```

### Code Splitting

**Dynamic Imports:**
```javascript
import dynamic from 'next/dynamic';

const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <div>Loading...</div>,
  ssr: false, // Load only on client
});

export default function Page() {
  return <HeavyComponent />;
}
```

### Script Optimization

```javascript
import Script from 'next/script';

export default function Layout({ children }) {
  return (
    <>
      <Script
        src="https://analytics.example.com/script.js"
        strategy="afterInteractive"
      />
      {children}
    </>
  );
}
```

**Script Strategies:**
- `beforeInteractive` - Execute before any React code
- `afterInteractive` - Execute after hydration (default)
- `lazyOnload` - Execute during idle time
- `worker` - Run in web worker

### Caching

**Browser Cache:**
```javascript
export const revalidate = 3600; // Cache for 1 hour
```

**CDN Cache:**
```javascript
export async function GET(request) {
  return Response.json(data, {
    headers: {
      'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',
    },
  });
}
```

### Web Vitals

Track Core Web Vitals:
```javascript
// app/layout.js
'use client';

import { useReportWebVitals } from 'next/web-vitals';

export function WebVitals() {
  useReportWebVitals((metric) => {
    console.log(metric);
  });
}

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <WebVitals />
        {children}
      </body>
    </html>
  );
}
```

---

## Deployment

### Build and Production

```bash
# Build the project
npm run build

# Start production server
npm run start

# Development server
npm run dev
```

### Environment Variables

```
# .env.local
DATABASE_URL=postgresql://...
API_SECRET=secret123

# .env.production
DATABASE_URL=production_db_url
```

**Using Environment Variables:**
```javascript
const dbUrl = process.env.DATABASE_URL;

// Client-side (must be prefixed with NEXT_PUBLIC)
const apiUrl = process.env.NEXT_PUBLIC_API_URL;
```

### Deployment Platforms

**Vercel (Recommended):**
- Optimal Next.js support
- Zero-config deployment
- Automatic previews
- Edge functions support
- Analytics included

**Docker Deployment:**
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build
CMD ["npm", "run", "start"]
EXPOSE 3000
```

**Self-Hosted:**
```bash
# Build
npm run build

# Start
npm run start
# Set NODE_ENV=production
```

### Build Optimization

**next.config.js:**
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Compression
  compress: true,

  // Image optimization
  images: {
    formats: ['image/avif', 'image/webp'],
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'example.com',
      },
    ],
  },

  // Environment variables
  env: {
    API_URL: process.env.API_URL,
  },

  // Headers
  async headers() {
    return [
      {
        source: '/api/:path*',
        headers: [
          { key: 'X-Content-Type-Options', value: 'nosniff' },
        ],
      },
    ];
  },

  // Redirects
  async redirects() {
    return [
      {
        source: '/old-page',
        destination: '/new-page',
        permanent: true,
      },
    ];
  },
};

module.exports = nextConfig;
```

---

## Best Practices

### Code Organization

**Recommended Structure:**
```
src/
├── app/                 # App Router
├── components/          # Reusable components
│   ├── ui/             # UI components
│   ├── layout/         # Layout components
│   └── forms/          # Form components
├── lib/                # Utilities and helpers
├── hooks/              # Custom React hooks
├── services/           # API services
├── types/              # TypeScript types
└── styles/             # Global styles
```

### Performance Best Practices

1. **Use Server Components by Default** - Reduces JavaScript bundle
2. **Lazy Load Components** - Use dynamic imports
3. **Optimize Images** - Use Next.js Image component
4. **Implement Caching** - Use ISR and CDN cache
5. **Code Splitting** - Automatic, but monitor bundle size
6. **Prefetch Links** - Use prefetch in Link components
7. **Stream HTML** - Use Suspense boundaries
8. **Monitor Metrics** - Track Web Vitals

### Security Best Practices

1. **Validate Input** - Always validate user input
2. **Sanitize Output** - Prevent XSS attacks
3. **Use HTTPS** - Secure transmission
4. **Secure Cookies** - httpOnly, Secure, SameSite flags
5. **CSRF Protection** - Use tokens for state-changing operations
6. **Rate Limiting** - Prevent brute force attacks
7. **Environment Secrets** - Never hardcode secrets
8. **Keep Dependencies Updated** - Security patches

### Development Best Practices

1. **Type Safety** - Use TypeScript
2. **Testing** - Write unit and integration tests
3. **Error Handling** - Use error boundaries and error.js
4. **Logging** - Log important events
5. **Monitoring** - Use tools like Sentry for error tracking
6. **Documentation** - Document your code and APIs
7. **Code Review** - Review code before merging
8. **CI/CD** - Automate testing and deployment

### SEO Best Practices

1. **Metadata** - Use metadata export
2. **Structured Data** - Use JSON-LD for schema markup
3. **Sitemap** - Generate sitemap.xml
4. **Robots.txt** - Control crawler access
5. **Open Graph** - Social media sharing metadata
6. **Mobile Friendly** - Responsive design
7. **Core Web Vitals** - Optimize performance

---

## Summary

Next.js is a powerful React framework that provides:
- **Multiple rendering strategies** for different use cases
- **Built-in optimizations** for performance
- **File-based routing** for simplicity
- **API routes** for backend functionality
- **Authentication support** with middleware
- **Deployment flexibility** with multiple hosting options

By mastering Next.js concepts and best practices, you can build high-performance, SEO-friendly web applications with excellent developer experience.
